<?xml version='1.0' encoding='utf-8'?>
<scheme version="2.0" title="" description="">
	<nodes>
		<node id="0" name="Python Script" qualified_name="Orange.widgets.data.owpythonscript.OWPythonScript" project_name="Orange3" version="" title="Dbpedia abstracts" position="(177.0, 259.0)" />
		<node id="1" name="Display" qualified_name="_textable.widgets.OWTextableDisplay.OWTextableDisplay" project_name="Orange3-Textable" version="" title="Display" position="(291.0, 10.0)" />
		<node id="2" name="Python Script" qualified_name="Orange.widgets.data.owpythonscript.OWPythonScript" project_name="Orange3" version="" title="TextSummarizer" position="(411.0, 271.0)" />
	</nodes>
	<links>
		<link id="0" source_node_id="0" sink_node_id="1" source_channel="Object" sink_channel="Segmentation" enabled="true" />
		<link id="1" source_node_id="0" sink_node_id="2" source_channel="Object" sink_channel="Object" enabled="true" />
	</links>
	<annotations />
	<thumbnail />
	<node_properties>
		<properties node_id="0" format="literal">{'controlAreaVisible': True, 'currentScriptIndex': 0, 'savedWidgetGeometry': b'\x01\xd9\xd0\xcb\x00\x03\x00\x00\x00\x00\x05\x00\x00\x00\x01\xe0\x00\x00\x07\x81\x00\x00\x04r\x00\x00\x05\x01\x00\x00\x01\xfa\x00\x00\x07\x80\x00\x00\x04m\x00\x00\x00\x00\x00\x00\x00\x00\n\x00\x00\x00\x05\x01\x00\x00\x01\xfa\x00\x00\x07\x80\x00\x00\x04m', 'scriptLibrary': [{'name': 'corpus.py', 'script': '"""\nScript pour widget "Python Script" dans Orange-Canvas pour\ncreer une segmentation a partir de DBpedia:\n    un segment contient le texte de la description dbpedia\n    et une annotation avec le nom de la personne\n"""\n\nimport re\nfrom SPARQLWrapper import SPARQLWrapper, JSON\nfrom LTTL.Segmentation import Segmentation\nfrom LTTL.Segment import Segment\nfrom LTTL.Input import Input\n \nsparql_endpoint = SPARQLWrapper("http://dbpedia.org/sparql")\nsparql_endpoint.setReturnFormat(JSON)\nquery = """\nselect distinct ?subject ?name ?abstract where {\n  ?subject a dbo:Artist;\n           dbo:abstract ?abstract;\n           foaf:name ?name;\n           rdfs:label ?label .\n   FILTER (lang(?abstract) = \'en\')\n   FILTER (lang(?name) = \'en\')\n   FILTER (lang(?label) = \'en\')\n} LIMIT 100\n\n"""\nsparql_endpoint.setQuery(query)\n\ndocuments = sparql_endpoint.queryAndConvert()\n\n# Changement de structure:\ndocuments = {entry["name"]["value"]:entry["abstract"]["value"] for entry in documents["results"]["bindings"] }\n\nsegmentation = Input(" ".join(documents.values()))\n\nsegments = list()\n\nstart = 0\nfor name, text in documents.items():\n    length = len(text)\n    segments.append(\n        Segment(\n            str_index=segmentation[0].str_index,\n            start = start,\n            end=start + length,\n            annotations={"id": name}\n        )\n    )\n    start = start + length + 1\n\nout_object = Segmentation(segments)\n', 'filename': 'D:/MyDocs/Enseignement/prog_texte/A17/seance07/tp07_solution/tp07_solution.py'}], 'scriptText': '"""\nScript pour widget "Python Script" dans Orange-Canvas pour\ncreer une segmentation a partir de DBpedia:\n    un segment contient le texte de la description dbpedia\n    et une annotation avec le nom de la personne\n"""\n\nimport re\nfrom SPARQLWrapper import SPARQLWrapper, JSON\nfrom LTTL.Segmentation import Segmentation\nfrom LTTL.Segment import Segment\nfrom LTTL.Input import Input\n \nsparql_endpoint = SPARQLWrapper("http://dbpedia.org/sparql")\nsparql_endpoint.setReturnFormat(JSON)\nquery = """\nselect distinct ?subject ?name ?abstract where {\n  ?subject a dbo:Artist;\n           dbo:abstract ?abstract;\n           foaf:name ?name;\n           rdfs:label ?label .\n   FILTER (lang(?abstract) = \'en\')\n   FILTER (lang(?name) = \'en\')\n   FILTER (lang(?label) = \'en\')\n} LIMIT 100\n\n"""\nsparql_endpoint.setQuery(query)\n\ndocuments = sparql_endpoint.queryAndConvert()\n\n# Changement de structure:\ndocuments = {entry["name"]["value"]:entry["abstract"]["value"] for entry in documents["results"]["bindings"] }\n\nsegmentation = Input(" ".join(documents.values()))\n\nsegments = list()\n\nstart = 0\nfor name, text in documents.items():\n    length = len(text)\n    segments.append(\n        Segment(\n            str_index=segmentation[0].str_index,\n            start = start,\n            end=start + length,\n            annotations={"id": name}\n        )\n    )\n    start = start + length + 1\n\nout_object = Segmentation(segments)\n', 'splitterState': b'\x00\x00\x00\xff\x00\x00\x00\x01\x00\x00\x00\x02\x00\x00\x00n\x00\x00\x00n\x01\xff\xff\xff\xff\x01\x00\x00\x00\x02\x00', '__version__': 2}</properties>
		<properties node_id="1" format="literal">{'autoSend': True, 'basicFormatHTML': True, 'controlAreaVisible': True, 'customFormat': '%(__content__)s', 'customFormatting': True, 'displayAdvancedSettings': False, 'encoding': 'utf8', 'footer': '', 'header': '', 'lastLocation': '.', 'limitNumberOfSegments': True, 'savedWidgetGeometry': b'\x01\xd9\xd0\xcb\x00\x03\x00\x00\x00\x00\x05\x00\x00\x00\x01\xe0\x00\x00\x07\x81\x00\x00\x03\xde\x00\x00\x05\x01\x00\x00\x01\xfa\x00\x00\x07\x80\x00\x00\x03\xd9\x00\x00\x00\x00\x00\x00\x00\x00\n\x00\x00\x00\x05\x01\x00\x00\x01\xfa\x00\x00\x07\x80\x00\x00\x03\xd9', 'segmentDelimiter': '\\n', 'uuid': 'e03324fc-fc09-4d10-be1e-f47478fec4b2', '__version__': 1, '_TextableUtils_settings_version__': (0, 16)}</properties>
		<properties node_id="2" format="literal">{'controlAreaVisible': True, 'currentScriptIndex': 0, 'savedWidgetGeometry': b'\x01\xd9\xd0\xcb\x00\x02\x00\x00\x00\x00\x01\xb4\x00\x00\x00\xb4\x00\x00\x06;\x00\x00\x03\x90\x00\x00\x01\xb8\x00\x00\x00\xcb\x00\x00\x067\x00\x00\x03\x8c\x00\x00\x00\x00\x00\x00\x00\x00\x06\x90', 'scriptLibrary': [{'name': 'tp07_solution.py', 'script': '"""Programmation pour le texte I, TP8, corrige\nGeneration de texte aleatoire par chaine de Markov, sur la base des transitions\nobservees dans un texte et stockees dans une table de contingence.\n"""\n\nfrom LTTL.Input import Input\nfrom LTTL.Utils import tuple_to_simple_dict, sample_dict\n\n\ndef main():\n    """Programme principal"""\n    global out_object\n\n    # Parametres...\n    num_strings = 1000\n    delimiter = ""\n    intra_seq_delim = "#"\n\n    # Initialisation.\n    strings = list()\n\n    # Tirage de la sequence initiale et calcul de l\'ordre la chaine...\n    previous_seq = in_object.row_ids[0]\n    order = previous_seq.count(intra_seq_delim) + 1\n\n    # Remplacement du delimiteur par un espace et stockage de la chaine.\n    strings.append(previous_seq.replace(intra_seq_delim, " "))\n\n    # Boucle de tirage des chaines successives...\n    for _ in range(num_strings - order + 1):\n\n        # Obtention du dictionnaire de frequence des successeurs possibles\n        # de la chaine tiree precedemment...\n        freq = tuple_to_simple_dict(in_object.values, previous_seq)\n\n        try:\n            # Tirage d\'une cle dans le dictionnaire des successeurs\n            new_string = next(iter(sample_dict(freq, 1)))\n\n            # Remplacement du delimiteur par un espace et stockage de la chaine\n            strings.append(new_string.replace(intra_seq_delim, " "))\n\n            # Mise a jour de la chaine precedente.\n            previous_seq = update(previous_seq, new_string, intra_seq_delim)\n\n        # Sortir de la boucle en cas d\'impasse (transition impossible)...\n        except ValueError:\n            break\n\n    # Concatenation des chaines tirees puis creation et renvoi d\'un Input.\n    out_object = Input(delimiter.join(strings))\n    \n\ndef update(previous_seq, new_string, intra_seq_delim):\n    """Mise a jour de la chaine precedente en fonction de la chaine\n    nouvellement tiree.\n\n    &gt;&gt;&gt; update("un#exemple", "simple", "#")\n    \'exemple#simple\'\n    """\n    strings = previous_seq.split(intra_seq_delim)\n    strings = strings[1:]\n    strings.append(new_string)\n    return intra_seq_delim.join(strings)\n\n\nif __name__ == "builtins":\n    if in_object:\n        main()\n', 'filename': 'D:/MyDocs/Enseignement/prog_texte/A17/seance07/tp07_solution/tp07_solution.py'}], 'scriptText': '"""Programmation pour le texte I, TP8, corrige\nGeneration de texte aleatoire par chaine de Markov, sur la base des transitions\nobservees dans un texte et stockees dans une table de contingence.\n"""\n\nfrom LTTL.Input import Input\nfrom LTTL.Utils import tuple_to_simple_dict, sample_dict\n\n\ndef main():\n    """Programme principal"""\n    global out_object\n\n    # Parametres...\n    num_strings = 1000\n    delimiter = ""\n    intra_seq_delim = "#"\n\n    # Initialisation.\n    strings = list()\n\n    # Tirage de la sequence initiale et calcul de l\'ordre la chaine...\n    previous_seq = in_object.row_ids[0]\n    order = previous_seq.count(intra_seq_delim) + 1\n\n    # Remplacement du delimiteur par un espace et stockage de la chaine.\n    strings.append(previous_seq.replace(intra_seq_delim, " "))\n\n    # Boucle de tirage des chaines successives...\n    for _ in range(num_strings - order + 1):\n\n        # Obtention du dictionnaire de frequence des successeurs possibles\n        # de la chaine tiree precedemment...\n        freq = tuple_to_simple_dict(in_object.values, previous_seq)\n\n        try:\n            # Tirage d\'une cle dans le dictionnaire des successeurs\n            new_string = next(iter(sample_dict(freq, 1)))\n\n            # Remplacement du delimiteur par un espace et stockage de la chaine\n            strings.append(new_string.replace(intra_seq_delim, " "))\n\n            # Mise a jour de la chaine precedente.\n            previous_seq = update(previous_seq, new_string, intra_seq_delim)\n\n        # Sortir de la boucle en cas d\'impasse (transition impossible)...\n        except ValueError:\n            break\n\n    # Concatenation des chaines tirees puis creation et renvoi d\'un Input.\n    out_object = Input(delimiter.join(strings))\n    \n\ndef update(previous_seq, new_string, intra_seq_delim):\n    """Mise a jour de la chaine precedente en fonction de la chaine\n    nouvellement tiree.\n\n    &gt;&gt;&gt; update("un#exemple", "simple", "#")\n    \'exemple#simple\'\n    """\n    strings = previous_seq.split(intra_seq_delim)\n    strings = strings[1:]\n    strings.append(new_string)\n    return intra_seq_delim.join(strings)\n\n\nif __name__ == "builtins":\n    if in_object:\n        main()\n', 'splitterState': b'\x00\x00\x00\xff\x00\x00\x00\x01\x00\x00\x00\x02\x00\x00\x00n\x00\x00\x00n\x01\xff\xff\xff\xff\x01\x00\x00\x00\x02\x00', '__version__': 2}</properties>
	</node_properties>
	<session_state>
		<window_groups />
	</session_state>
</scheme>
